<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-02-09T23:51:08.007164"><title>Enhancing VKS Security with Falco Monitoring | Instance Name</title><script type="application/json" id="virtual-toc-data">[{"id":"what-is-falco","level":0,"title":"What is Falco","anchor":"#what-is-falco"},{"id":"prerequisites-requirements-and-recommendations","level":0,"title":"Prerequisites, Requirements and Recommendations.","anchor":"#prerequisites-requirements-and-recommendations"},{"id":"deploying-falco-to-vks-workload-cluster","level":0,"title":"Deploying Falco to VKS Workload Cluster","anchor":"#deploying-falco-to-vks-workload-cluster"},{"id":"events-based-on-falco-starter-kubernetes-ruleset","level":0,"title":"Events Based on Falco Starter Kubernetes Ruleset","anchor":"#events-based-on-falco-starter-kubernetes-ruleset"},{"id":"tuning-and-testing-falco-eventing","level":0,"title":"Tuning and Testing Falco Eventing","anchor":"#tuning-and-testing-falco-eventing"},{"id":"testing-falco-on-vks-with-customized-rules","level":0,"title":"Testing Falco on VKS with Customized Rules","anchor":"#testing-falco-on-vks-with-customized-rules"},{"id":"best-practices-for-pre-production-testing","level":0,"title":"Best Practices for Pre-Production Testing","anchor":"#best-practices-for-pre-production-testing"},{"id":"what-learned","level":0,"title":"What you\u0027ve Learned","anchor":"#what-learned"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Enhancing VKS Security with Falco Monitoring | Instance Name"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Instance Name Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/tutorial.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Enhancing VKS Security with Falco Monitoring | Instance Name"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/tutorial.html#webpage",
    "url": "writerside-documentation/tutorial.html",
    "name": "Enhancing VKS Security with Falco Monitoring | Instance Name",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Instance Name Help"
}</script><!-- End Schema.org --></head><body data-id="tutorial" data-main-title="Enhancing VKS Security with Falco Monitoring" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Instance Name  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="tutorial" id="tutorial.md">Enhancing VKS Security with Falco Monitoring</h1><p id="-cdsspw_3">The rate of customers adopting the Kubernetes platform to host cloud-native applications for production use is quickly increasing. As expected with enterprise production applications, Kubernetes adoption is matched by compliance and security concerns. Starting with image security, the application team protects the supply chain by performing image scans to guard against critical vulnerabilities and confirm image provenance, using scanning tools such as Trivy and Notary. A great complement to this supply chain security would be a runtime monitoring solution on the vSphere Kubernetes Service (VKS) platform that observes the behavior of the container workloads in our cluster to detect potentially malicious activities. Falco is a real-time security monitoring solution that serves this purpose quite well. In this document, we will explore getting started with Falco on VKS. At a high level, we will perform the following.</p><ul class="list _bullet" id="-cdsspw_4"><li class="list__item" id="-cdsspw_13"><p>Deploy Falco Threat Detection for Real-time VKS Worker Cluster Monitoring</p></li><li class="list__item" id="-cdsspw_14"><p>Test and Review Out-of-the-Box Falco Rule Set</p></li><li class="list__item" id="-cdsspw_15"><p>Customize Falco Rule Set for vSphere Kubernetes Service</p></li><li class="list__item" id="-cdsspw_16"><p>Consider Best Practice for Pre-Production Testing of Falce</p></li></ul><section class="chapter"><h2 id="what-is-falco" data-toc="what-is-falco">What is Falco</h2><p id="-cdsspw_17"><a href="https://falco.org/" id="-cdsspw_19" data-external="true" rel="noopener noreferrer">Falco</a> is a cloud-native, open-source, runtime threat detection solution that surveils application system calls. Falco was eagerly accepted to CNCF on October 10, 2018. Falco achieved its current status of Graduated on February 29, 2024. Falco can perform threat detection for Kubernetes, containers, virtual machines, and physical hosts. Falco leverages <a href="https://ebpf.io/what-is-ebpf/" id="-cdsspw_20" data-external="true" rel="noopener noreferrer">Enhanced Berkley Packet Filtering (eBPF)</a>, to probe the operating system kernel for submitted system calls. The Falco eBPF probe compares the system calls and parameters to the ruleset to determine if the system call indicates a potential threat or a pattern that may indicate a compromised resource. An example may be a user executing a shell on a running container or accessing security-sensitive files or configurations. It's important to note that Falco's role is not to prevent potentially malicious activity. The critical role Falco performs is detection and alerting. With this information, DevSecOps teams can create methods to prevent or remediate threats uncovered by Falco.</p><p id="-cdsspw_18">Falco's primary threat detection method is via input from the kernel probe, specifically, system calls submitted by cluster workloads. However, Falco is capable of receiving input from other resources, such as logs and audit files. This functionality is possible via Falco's plugin architecture. Enabling cluster audit logging for Falco k8saudit-log plugins adds additional context to the threat protection data that Falco provides with its Modern eBPF kernel probe. The Modern eBPF Kernel Probe is the preferred instrumentation over kernel module instrumentation. While I consider including Kubernetes audit logging as a best practice, it's out of the scope of this document.</p></section><section class="chapter"><h2 id="prerequisites-requirements-and-recommendations" data-toc="prerequisites-requirements-and-recommendations">Prerequisites, Requirements and Recommendations.</h2><p id="-cdsspw_21">Make sure that:</p><ul class="list _bullet" id="-cdsspw_22"><li class="list__item" id="-cdsspw_23"><p>You Have Enabled vSphere Kubernetes Service on ESX 8u3 vSphere Cluster - <a href="https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere-supervisor/8-0/installing-and-configuring-vsphere-supervisor/supervisor-installation-and-configuration-workflow.html" id="-cdsspw_29" data-external="true" rel="noopener noreferrer">Here's How</a></p></li><li class="list__item" id="-cdsspw_24"><p>A vSphere Kubernetes Workload Cluster is Up and Running in vSphere Namespace with a storage class assigned.</p></li><li class="list__item" id="-cdsspw_25"><p>You Have Edit Privilege on the Target Workload Cluster.</p></li><li class="list__item" id="-cdsspw_26"><p>Kubernetes CLI with vSphere Plugin Installed on Workstation.</p></li><li class="list__item" id="-cdsspw_27"><p>Helm 3.17 or Greater CLI installed and ability to Access Falco Helm Chart Repository.</p></li><li class="list__item" id="-cdsspw_28"><p>Have Internet access to download Falco Helm Charts.</p></li></ul></section><section class="chapter"><h2 id="deploying-falco-to-vks-workload-cluster" data-toc="deploying-falco-to-vks-workload-cluster">Deploying Falco to VKS Workload Cluster</h2><p id="-cdsspw_30">Three primary methods exist to install Falco security monitoring at scale on VKS worker clusters. Installing Falco via Kustomized YAML templates or modifying the YAML manually for one-off deployment is possible. The manual editing method requires more configuration effort but allows the administrator to fine-tune the Falco deployment directly. The third and recommended method of deploying Falco to a workload cluster is via Helm, leveraging its values file or many command-line set options to customize the implementation. This document will focus on Helm for Falco deployment, configuration, and lifecycle management. The latest Helm version installed on your jump box or workstation is a requirement. Helm is installable via your favorite or native package manager. I have installed Helm using Brew for MacOS. Complete details for installing Helm for all platforms may be found here: <a href="https://helm.sh/docs/install/" id="-cdsspw_49" data-external="true" rel="noopener noreferrer">Helm Install</a></p><p id="-cdsspw_31">I have a target workload cluster deployed running Kubernetes v1.30.1, based on Ubuntu, comprised of one control-plane node and three worker nodes, configured with VMClass best-effort-small.</p><ol class="list _decimal" id="-cdsspw_32" type="1"><li class="list__item" id="-cdsspw_50"><p id="-cdsspw_53">Confirm functionality of Helm CLI. If required, reference <a href="https://helm.sh/docs/faq/troubleshooting/" id="-cdsspw_55" data-external="true" rel="noopener noreferrer">Helm Troubleshooting</a></p><div class="code-block" data-lang="bash">
 helm version
</div></li><li class="list__item" id="-cdsspw_51"><p id="-cdsspw_56">To add and update available charts in the Falco repository as a resource to the Helm enviornment, issue the following commands.</p><div class="code-block" data-lang="bash">
helm repo add falcosecurity https://falcosecurity.github.io/charts
helm update
</div></li><li class="list__item" id="-cdsspw_52"><p id="-cdsspw_58">Connect to target workload cluster using kubectl and the vsphere plugin and set context to target cluster. Create a namespace for Falco and configure pod security for privileged access.</p></li></ol><aside class="prompt" data-type="note" data-title="" id="-cdsspw_33"><p>Your cluster may be configured to automatically label newly created namespaces with privileged enforced. If so, you may skip the namespace labeling step.</p></aside><div class="code-block" data-lang="bash">
kubectl create namespace falco
kubectl get namespace falco --show-labels
kubectl label namespace falco pod-security.kubernetes.io/enforce=privileged --overwrite
</div><ol class="list _decimal" id="-cdsspw_35" type="1" start="4"><li class="list__item" id="-cdsspw_59"><p id="-cdsspw_61">Using Helm, install Falco monitoring with it default event rules, and Sidekick dashboard for event viewing. Specifying the storage class is required if the cluster does not have a storage class designated as default.</p><div class="code-block" data-lang="bash">
helm install falco --set falcosidekick.enabled=true --set falcosidekick.webui.enabled=true \
--namespace falco --set webui.redis.storageClass=[YOUR-STORAGE-CLASS]
</div></li><li class="list__item" id="-cdsspw_60"><p id="-cdsspw_63">By default, Falco Sidekick is configured as service type ClusterIP. In the case the dashboard would be accessible via port forwarding. This is configurable via the Helm values file, but for this testing we will continue with the default.</p></li></ol><div class="code-block" data-lang="bash">
kubectl -n falco port-forward svc/falco-falcosidekick-ui 2802
</div><p id="-cdsspw_37">With the above the sidekick dashboard should be available via: http://localhost:2802 Default Login Credentials: admin/admin</p><ol class="list _decimal" id="-cdsspw_38" type="1" start="6"><li class="list__item" id="-cdsspw_64"><p><span class="control" id="-cdsspw_65">Optional Step:</span> You may change the Falco Kickstart UI service to service type from ClusterIP to LoadBalancer. I've done so, but it's not really required for basic testing.</p></li></ol><div class="code-block" data-lang="bash">
kubectl edit service falco-falcosidekick-ui -n falco
</div><div class="code-collapse" data-lang="yaml" data-is-expanded="false" data-synopsis="svc/falco-falcosidekick-ui">
  1 # Please edit the object below. Lines beginning with a '#' will be ignored,
  2 # and an empty file will abort the edit. If an error occurs while saving this file will be
  3 # reopened with the relevant failures.
  4 #
  5 apiVersion: v1
  6 kind: Service
  7 metadata:
  8   annotations:
  9     meta.helm.sh/release-name: falco
  10     meta.helm.sh/release-namespace: falco
  11   creationTimestamp: &quot;2025-02-09T17:07:43Z&quot;
  12   finalizers:
  13   - service.kubernetes.io/load-balancer-cleanup
  14   labels:
  15     app.kubernetes.io/component: ui
  16     app.kubernetes.io/instance: falco
  17     app.kubernetes.io/managed-by: Helm
  18     app.kubernetes.io/name: falcosidekick
  19     app.kubernetes.io/part-of: falcosidekick
  20     app.kubernetes.io/version: 2.30.0
  21     helm.sh/chart: falcosidekick-0.9.5
  22   name: falco-falcosidekick-ui
  23   namespace: falco
  24   resourceVersion: &quot;3005306&quot;
  25   uid: 680e0d1a-bfcd-4409-b2e1-6f8fe8ed583e
  26 spec:
  27   allocateLoadBalancerNodePorts: true
  28   clusterIP: 10.109.241.49
  29   clusterIPs:
  30   - 10.109.241.49
  31   externalTrafficPolicy: Cluster
  32   internalTrafficPolicy: Cluster
  33   ipFamilies:
  34   - IPv4
  35   ipFamilyPolicy: SingleStack
  36   ports:
  37   - name: http
  38     nodePort: 31924
  39     port: 2802
  40     protocol: TCP
  41     targetPort: 2802
  42   selector:
  43     app.kubernetes.io/component: ui
  44     app.kubernetes.io/instance: falco
  45     app.kubernetes.io/name: falcosidekick
  46   sessionAffinity: None
  47   type: LoadBalancer     # &lt;-- Changed from ClusterIP to LoadBalancer
  48 status:
  49   loadBalancer:
  50     ingress:
  51     - ip: 192.168.40.108
  52       ipMode: VIP
</div><p id="-cdsspw_41">Obtain your External IP using the following command.</p><div class="code-block" data-lang="bash">
kubectl get service falco-falcosidekick-ui -n falco
</div><figure id="-cdsspw_43"><img alt="Falco falcosidekick ui" src="images/falco-falcosidekick-ui.jpg" title="Falco falcosidekick ui" width="1017" height="104"></figure><p id="-cdsspw_44">In my case the external IP is and exposed port, provides dashboard access via the following address: http://192.168.40.108:2802</p><ol class="list _decimal" id="-cdsspw_45" type="1" start="6"><li class="list__item" id="-cdsspw_66"><p id="-cdsspw_67">Check the status of Falco to insure the Helm chart has properly deploy and all pods of the Falco daemonset and Sidekick deployment are in running state.</p><div class="code-block" data-lang="bash">
helm list -n falco 
watch kubectl get all -f falco
</div><figure id="-cdsspw_69"><img alt="Falco get all ns" src="images/falco-get-all-ns.jpg" title="Falco get all ns" width="1199" height="593"></figure></li></ol><p id="-cdsspw_46">Press <kbd class="keystroke" id="-cdsspw_70" data-bypass="true"><span class="keystroke__value">Ctrl+C</span></kbd> to stop watching Falco status.</p><ol class="list _decimal" id="-cdsspw_47" type="1" start="7"><li class="list__item" id="-cdsspw_71"><p>Login to the Falco Sidekick portal to review syscall events based on the OOTB Falco K8s Ruleset. In my case the service falco-falcosidekick-ui is reachable via http://192.168.40.108:2802.</p></li></ol><aside class="prompt" data-type="note" data-title="" id="-cdsspw_48"><p>The Sidekick portal is configured as insecure for our temporary use case and ease of viewing the syscall events to inform tuning of the the default ruleset. For long term use of this portal, a verifiable certificate should be configured.</p></aside></section><section class="chapter"><h2 id="events-based-on-falco-starter-kubernetes-ruleset" data-toc="events-based-on-falco-starter-kubernetes-ruleset">Events Based on Falco Starter Kubernetes Ruleset</h2><p id="-cdsspw_72">As mentioned previously, Falco provides an Out-Of-The-Box ruleset to evaluate system calls and parameters for potential security threats. These OOTB rules are based on sound principles and best practices for generic Kubernetes clusters. The ruleset does not factor in using the vSphere CSI or other operational VKS workload cluster components.</p><p id="-cdsspw_73">As we review the initial events in the Sidekick dashboard, we notice many events numbering in the 100s of events over time. The portal indicates the rule violation is: Contact K8s API Server From Container. Let's investigate the details of this event, which is causing a large number of entries in our Sidekick dashboard. <figure id="-cdsspw_80"><img alt="Kapp events dashboard" src="images/kapp-events-dashboard.jpg" title="Kapp events dashboard" width="1105" height="1279"></figure></p><p id="-cdsspw_74">Reviewing event details, we find that the offending container is the kapp-controller under the cluster namespace tkg-system. The Kapp-controller is clearly a VKS Service that eases the effort of operationalizing workload clusters by managing the deployment and lifecycle of cluster service packages, such as Grafana.</p><figure id="-cdsspw_75"><img alt="Kapp event details" src="images/kapp-event-details.jpg" title="Kapp event details" width="2867" height="176"></figure><p id="-cdsspw_76">Investigating the Falco default ruleset file, which is local on each node pod, managed by a daemon set, located /etc/Falco/falco_rules.yaml. The condition for the rule Contact K8s API Server From Container is a container running in the cluster that contacts the API server and is not present in the macro K8s_containers, a list of known OOTB containers. Another exception to this condition is containers listed under the macro: user_known_contact_k8s_api_server_activities. This undefined macro allows the platform administrator to identify containers typical to a VKS workload cluster and has expected contact with the API server. The undefined macro, user_known_contact_k8s_api_server, is a facility to modify the influence of the ruleset without directly modifying the based Falco ruleset, which is not recommended, as the base ruleset is updated and managed externally. Thus, modifications to the base ruleset may be overridden as the CNCF Falco Organization updates the base ruleset.</p><figure id="-cdsspw_77"><img alt="Falco base k8s contact rule" src="images/falco-base-k8s-contact-rule.jpg" title="Falco base k8s contact rule" width="2066" height="932"></figure><p id="-cdsspw_78">Let's create a macro, using the undefined user_known_contact_k8s_api_activities to define our known VKS containers. I should note that in addition to the kapp-controller, though less frequent, I noted additional container events listed in the Falco Sidekick dashboard that shuld be defined in our user_known_contact_k8s_api_activities macro.</p><aside class="prompt" data-type="note" data-title="" id="-cdsspw_79"><p>The Falco events are viewable via command line using kubectl logs as well. We are using the portal to assist in extending the OOTB ruleset, as the Sidekick portal highlights keywords that may be used in when creating Falco rules, macros and list. The fields hightlighted in blue indicate available keywords that we will leverage with rule and macro creation.</p></aside></section><section class="chapter"><h2 id="tuning-and-testing-falco-eventing" data-toc="tuning-and-testing-falco-eventing">Tuning and Testing Falco Eventing</h2><p id="-cdsspw_81">Again, Falco provides a great starter, OOTB ruleset, to evaluate system calls and parameters from VKS clusters for potential security threats, which may include regular container and controller behavior. On the one hand, reporting normal cluster behavior on a regular basis could assist in identifying anomalous or deviating cluster behavior. If you agree with this approach, notification of expected behavior may be helpful. However, if your focus is more event-based, recording these typical and expected events may become &quot;noise&quot;, diminishing the usefulness of events and alerts.</p><p id="-cdsspw_82">In the context of operations, we commonly refer to this conversation as the signal-to-noise ratio. We want a &quot;5x5&quot;, clear signal, and a low noise ratio. In other words, we want clear indicators of events requiring attention versus a large number of informative or unclassified events requiring no decisive conversations or actions. For this reason, we will observe the Falcosidekick UI to identify expected communications and tune the ruleset to eliminate the volume of uninteresting syscall events. The immediate standout events are related to the VKS kapp-controller. The Kapp-controller is a package management solution unique to VKS; the Falco OOTB rulesets will consider system calls from the Kapp-controller potentially suspect. Applicable software packages added via the kapp-controller, or any software management solution may be considered suspect and reported by Falco as unexpected. Examining events in the Falco Sidekick portal, filtering on priority &quot;Notice,&quot; I see several entries based on VKS controllers, including containers Kapp-controller and vsphere-syncer; both are expected and required API server connections for a properly functioning VKS cluster.</p><figure id="-cdsspw_83"><img alt="Sidekick controller events" src="images/sidekick-controller-events.jpg" title="Sidekick controller events" width="3157" height="1094"></figure><p id="-cdsspw_84">Let's tune the Falco default ruleset. You may have noticed in the previous screenshot that the default ruleset allows API server access for containers in the cluster namespace kube-system. I will use the same pattern to accommodate my VKS system containers. I will redefine the macro: user_known_contact_k8s_api_server_activities to include the cluster namespaces that start with vmware-system and are named tkg-system. Here is the YAML defining this Falco macro, in a file named vks_falco_rules.yaml (copy the contents code below to a file named vks_falco_rules.yaml).</p><div class="code-block" data-lang="yaml">
- macro: user_known_contact_k8s_api_server_activities
  condition: (k8s.ns.name startswith vmware-system or k8s.ns.name=tkg-system)
</div><p id="-cdsspw_86">Now, let's test this macro on our workload cluster. The expectation is that Falco threat detection will not event on system calls from containers in the cluster namespaces starting with vmware-system or named tkg-system. For ease of testing, let's uninstall the current test Falco deployment</p><div class="code-block" data-lang="bash">
helm list -n falco
helm unistall falco -n falco
</div><p id="-cdsspw_88">Now with a VKS customized rule based, free of extraneous events, let's redeploy Falco with our custom rule definition (vks_falco_rules.yaml), consisting of our redefinition of the macro user_know_contact_k8s_api_server_activities.</p><div class="code-block" data-lang="bash">
helm install falco -f vks_falco_rules.yaml --set falcosidekick.enabled=true \
--set falcosidekick.webui.enabled=true  \
--namespace falco --set webui.redis.storageClass=[YOUR-STORAGE-CLASS]
</div><p id="-cdsspw_90">Now, let's review our Falco Sidekick portal, specifying a time window os 15 minutes to avoid messages prior to application of our redefined macro which includes our VKS system containers.</p></section><section class="chapter"><h2 id="testing-falco-on-vks-with-customized-rules" data-toc="testing-falco-on-vks-with-customized-rules">Testing Falco on VKS with Customized Rules</h2><p id="-cdsspw_91">We now review the Falco Sidekick dashboard with a time window of 15 mins. It confirms that the VKS customized macro we put in place has reduced uninteresting and expected system call activity.</p><p id="-cdsspw_92">Let's now perform a test using the Falco pods, which are also under security surveillance. The following activity should be observed and noted in the Falco Sidekick dashboard.</p><ol class="list _decimal" id="-cdsspw_93" type="1"><li class="list__item" id="-cdsspw_96"><p>Login to Falco pod.</p></li><li class="list__item" id="-cdsspw_97"><p>Access security-sensitive files (cat /etc/shadow).</p></li><li class="list__item" id="-cdsspw_98"><p>Install and execute a binary/package not included with the container image (install VIM and execute VI).</p></li></ol><p id="-cdsspw_94">All of which are notable security events on a VKS worker cluster. Now easily observed by the DevSecOps team, free of event noise.</p><figure id="-cdsspw_95"><img alt="Security event tests" src="images/security_event_tests.jpg" title="Security event tests" width="2469" height="1001"></figure></section><section class="chapter"><h2 id="best-practices-for-pre-production-testing" data-toc="best-practices-for-pre-production-testing">Best Practices for Pre-Production Testing</h2><p id="-cdsspw_99">It's important to point out the focus of this document is pre-production testing and production best practices are not included in this documents. My strong recommendation would be to include Falco as a GitOps component, including customized VKS and application rules. For testing purposes, we created a customize VKS macro and included this in our testing via command-line. However, outside of testing, custom rules should be deployed to a Falco implementation via a configmap and version controlled. This practice will greatly ease the overhead of maintaining Falco and it's customized rulesets.</p><p id="-cdsspw_100">The great news is that Falco supports the use of configmap and will create the same with a bit of modification to the YAML to be past via the Helm values file along with volume mount instructions for the daemonset.</p></section><section class="chapter"><h2 id="what-learned" data-toc="what-learned">What you've Learned</h2><p id="-cdsspw_101">Falco is a lightweight tool capable of enhancing security strategies on VKS Kubernetes clusters by providing real-time threat detection via monitoring system calls and Kubernetes events to identify suspicious or unauthorized activities. It alerts based on well-known compliance with security standards, detection of privilege escalations, and safeguards against supply chain attacks. Most importantly, Falco is extensible, with a well defined set intrinsics. As an open-source CNCF project, Falco continuously evolves to provide proactive security, making it a powerful choice for securing VKS workload clusters.</p></section><div class="last-modified">Last modified: 10 February 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>